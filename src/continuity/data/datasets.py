"""Various data set implementations."""

import torch
import numpy as np
from typing import List
from continuity.data import tensor, Sensor, Observation, DataSet


class SelfSupervisedDataSet(DataSet):
    """
    A `SelfSupervisedDataSet` is a data set constructed from a set of
    observations that exports batches of observations and labels for
    self-supervised learning. Every data point is created by taking one
    sensor as label.

    Every batch consists of tuples `(x, u, y, v)`, where `x is the sensor positions,
    `u` is the sensor values, `x` is the label's coordinate and `v` is the label.

    Args:
        observations: List of observations.
        batch_size: Batch size.
        shuffle: Shuffle dataset.
    """

    def __init__(
        self,
        observations: List[Observation],
        batch_size: int,
        shuffle: bool = True,
    ):
        self.observations = observations
        self.batch_size = batch_size

        self.num_sensors = observations[0].num_sensors
        self.coordinate_dim = observations[0].sensors[0].coordinate_dim
        self.num_channels = observations[0].sensors[0].num_channels

        # Check consistency across observations
        for observation in self.observations:
            assert (
                observation.num_sensors == self.num_sensors
            ), "Inconsistent number of sensors."
            assert (
                observation.coordinate_dim == self.coordinate_dim
            ), "Inconsistent coordinate dimension."
            assert (
                observation.num_channels == self.num_channels
            ), "Inconsistent number of channels."

        self.x = []
        self.u = []
        self.y = []
        self.v = []

        for observation in self.observations:
            x, u = observation.to_tensors()

            for sensor in observation.sensors:
                y = tensor(sensor.x).unsqueeze(0)
                v = tensor(sensor.u).unsqueeze(0)

                # Add data point for every sensor
                self.x.append(x)
                self.u.append(u)
                self.y.append(y)
                self.v.append(v)

        self.x = torch.stack(self.x)
        self.u = torch.stack(self.u)
        self.y = torch.stack(self.y)
        self.v = torch.stack(self.v)

        super().__init__(self.x, self.u, self.y, self.v, self.batch_size, shuffle)

    def get_observation(self, i: int) -> Observation:
        """Return i-th original observation object.

        Args:
            i: Index of observation.

        Returns:
            Observation object.
        """
        return self.observations[i]


class Sine(SelfSupervisedDataSet):
    r"""Creates a data set of sine waves.

    The data set is generated by sampling sine waves at the given number of
    sensors placed evenly in the interval $[-1, 1]$. The wave length of the
    sine waves is evenly distributed between $\pi$ for the first observation
    and $2\pi$ for the last observation, respectively.

    The `Sine` dataset generates $N$ sine waves
    $$
    f(x) = \sin(w_k x), \quad w_k = 1 + \frac{k}{N-1}, \quad k = 0, \dots, N-1.
    $$
    As a `SelfSupervisedDataset` it exports batches of samples for self-supervised
    training, namely
    $$
    \left(\mathbf{x}, f(\mathbf{x}), x_j, f(x_j)\right), \quad \text{for } j = 1, \dots, M,
    $$
    where $\mathbf{x} = (x_i)_{i=1 \dots M}$ are the $M$ equidistantly
    distributed sensor positions.

    - coordinate_dim: 1
    - num_channels: 1

    Args:
        num_sensors: Number of sensors.
        size: Size of data set.
        batch_size: Batch size. Defaults to 32.
    """

    def __init__(self, num_sensors: int, size: int, batch_size: int = 32):
        self.num_sensors = num_sensors
        self.size = size

        self.coordinate_dim = 1
        self.num_channels = 1

        # Generate observations
        observations = [self.generate_observation(i) for i in range(self.size)]

        super().__init__(observations, batch_size)

    def generate_observation(self, i: float) -> Observation:
        """Generate observation

        Args:
            i: Index of observation (0 <= i <= size).
        """
        x = np.linspace(-1, 1, self.num_sensors)

        if self.size == 1:
            w = 1
        else:
            w = 1 + i / (self.size - 1)

        u = np.sin(w * np.pi * x)

        sensors = [Sensor(np.array([x]), np.array([u])) for x, u in zip(x, u)]

        return Observation(sensors)
