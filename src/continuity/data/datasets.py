"""Various data set implementations."""

import torch
import numpy as np
from typing import Tuple
from continuity.data import tensor
from torch import Tensor
from torch.utils.data import Dataset


class SelfSupervisedDataSet(Dataset):
    """
    A `SelfSupervisedDataSet` is a data set that exports observations and labels
    for self-supervised learning. Every data point is created by taking one
    sensor as label.

    Every sample consists of tuples `(x, u, y, v)`, where `x` contains the sensor
    positions, `u` the sensor values, and `y = x_i` and `v = u_i` are
    the label's coordinate its value for all `i`.

    Args:
        x: Sensor positions of shape (num_observations, num_sensors, coordinate_dim)
        u: Sensor values of shape (num_observations, num_sensors, num_channels)
    """

    def __init__(
        self,
        x: Tensor,
        u: Tensor,
    ):
        self.num_observations = u.shape[0]
        self.num_sensors = u.shape[1]
        self.coordinate_dim = x.shape[-1]
        self.num_channels = u.shape[-1]

        # Check consistency across observations
        for i in range(self.num_observations):
            assert (
                x[i].shape[-1] == self.coordinate_dim
            ), "Inconsistent coordinate dimension."
            assert (
                u[i].shape[-1] == self.num_channels
            ), "Inconsistent number of channels."

        xs, us, ys, vs = [], [], [], []

        for i in range(self.num_observations):
            # Add one data point for every sensor
            for j in range(self.num_sensors):
                y = x[i][j].unsqueeze(0)
                v = u[i][j].unsqueeze(0)

                xs.append(x[i])
                us.append(u[i])
                ys.append(y)
                vs.append(v)

        self.xs = torch.stack(xs)
        self.us = torch.stack(us)
        self.ys = torch.stack(ys)
        self.vs = torch.stack(vs)

        super().__init__()

    def __len__(self) -> int:
        return len(self.xs)

    def __getitem__(self, i: int) -> Tuple[Tensor, Tensor, Tensor, Tensor]:
        return self.xs[i], self.us[i], self.ys[i], self.vs[i]


class Sine(Dataset):
    r"""Creates a data set of sine waves.

    The data set is generated by sampling sine waves at the given number of
    sensors placed evenly in the interval $[-1, 1]$. The wave length of the
    sine waves is evenly distributed between $\pi$ for the first observation
    and $2\pi$ for the last observation, respectively.

    The `Sine` dataset generates $N$ sine waves
    $$
    f(x) = \sin(w_k x), \quad w_k = 1 + \frac{k}{N-1}, \quad k = 0, \dots, N-1.
    $$
    It exports batches of samples
    $$
    \left(\mathbf{x}, f(\mathbf{x}), \mathbf{x}, f(\mathbf{x})\right),
    $$
    $$
    where $\mathbf{x} = (x_i)_{i=1 \dots M}$ are the $M$ equidistantly
    distributed sensor positions.

    - coordinate_dim: 1
    - num_channels: 1

    Args:
        num_sensors: Number of sensors.
        size: Size of data set.
        batch_size: Batch size. Defaults to 32.
        shuffle: Shuffle data set. Defaults to True.
    """

    def __init__(self, num_sensors: int, size: int):
        self.num_sensors = num_sensors
        self.size = size

        self.coordinate_dim = 1
        self.num_channels = 1

        # Generate observations
        observations = [self.generate_observation(i) for i in range(self.size)]

        self.x = torch.stack([x for x, _ in observations])
        self.u = torch.stack([u for _, u in observations])

        # Use observations as labels
        self.y = self.x
        self.v = self.u

        super().__init__()

    def __len__(self) -> int:
        return self.size

    def __getitem__(self, i: int) -> Tuple[Tensor, Tensor, Tensor, Tensor]:
        return self.x[i], self.u[i], self.y[i], self.v[i]

    def generate_observation(self, i: float) -> Tuple[np.array, np.array]:
        """Generate observation

        Args:
            i: Index of observation (0 <= i <= size).
        """
        # Create x of shape (n, 1)
        x = np.linspace(-1, 1, self.num_sensors).reshape(-1, 1)

        if self.size == 1:
            w = 1
        else:
            w = 1 + i / (self.size - 1)

        u = np.sin(w * np.pi * x)

        return tensor(x), tensor(u)
